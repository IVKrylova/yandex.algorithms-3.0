// 27. Вывести маршрут максимальной стоимости
// Ограничение времени	1 секунда
// Ограничение памяти	256Mb
// Ввод	стандартный ввод или input.txt
// Вывод	стандартный вывод или output.txt
// В левом верхнем углу прямоугольной таблицы размером 
// N
// ×
// M
//  находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.
// Подсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

// Формат ввода
// В первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100 — размеры таблицы. Далее идет N строк, каждая из которых содержит M чисел, разделенных пробелами — описание таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.
// Формат вывода
// Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта сумма. Маршрут выводится в виде последовательности, которая должна содержать N-1 букву D, означающую передвижение вниз и M-1 букву R, означающую передвижение направо. Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.
// Пример
// Ввод	Вывод
// 5 5
// 9 9 9 9 9
// 3 0 0 0 0
// 9 9 9 9 9
// 6 6 6 6 8
// 9 9 9 9 9
// 74
// D D R R R R D D


function solve(input) {
    const data = input.toString().trim().split('\n');
    const [n, m] = data[0].split(' ').map(Number);
    const table = data.slice(1).map(el => el.split(' ').map(Number));
    const dp = Array.from(Array(n + 1), () => new Array(m + 1));

    for (let i = 0; i <= m; i++) {
        dp[0][i] = -1000;
    }

    for (let i = 1; i <= n; i++) {
        dp[i][0] = -1000;
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (i === 1 && j === 1) {
                dp[i][j] = table[0][0];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + table[i - 1][j - 1];
            }
        }
    }

    const res = [];
    let i = n;
    let j = m;
    while (i > 0 && j > 0) {
        if (Math.max(dp[i - 1][j], dp[i][j - 1]) === dp[i - 1][j]) {
            res.push('D');
            i--;
        } else {
            res.push('R');
            j--;
        }
    }

    return `${dp[n][m]}\n${res.reverse().slice(1).join(' ')}`;
}

const fs = require('fs');
const fileContent = fs.readFileSync('input.txt', 'utf8');
const result = solve(fileContent);
fs.writeFileSync('output.txt', result + '');
